# 202010317
## 为什么js是单线程的？
1、为什么js是单线程？
与用途有关。作为浏览器脚本语言，js的功能主要是与用户互动，以及操作DOM。决定了它只能是单线程，否则会带来复杂的同步问题。比如，假设js同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除这个节点，这时浏览器应该以哪个线程为准？

利用多核CPU的计算能力，H5提出Web Worker标准，允许js脚本创建多个线程，但是自线程完全受主线程控制，不得操作DOM。

## 浏览器解析渲染页面
[浏览器解析渲染页面](https://segmentfault.com/a/1190000006879700)
浏览器是一个边解析边渲染的过程。
- 浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树。等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上
- 涉及重绘和重排。DOM树节点中的每个元素都是以盒模型的形式存在，这些需要浏览器去计算其位置和大小等。这个过程称为relow；当盒模型的位置、大小以及其他属性，等确定下来之后，浏览器就开始绘制内容，如颜色、字体，这个过程称为重绘。
- 页面首次加载时必然会经历reflow和repain。reflow和repain过程都是非常消耗性能的，尤其在移动设备上，会破坏用户体验，有时会造成页面卡顿。
- js的解析是由浏览器中的js解析引擎完成的。js是单线程运行的，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。
  - JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。
  - 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。
### web优化
- 能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。
- 如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;
- 减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。
- 当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。

### 为什么js是单线程的？
进程：进程一次只执行一个任务

原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说太复杂了

### 什么是 Event Loop？
[什么是 Event Loop？](http://www.ruanyifeng.com/blog/2013/10/event_loop.html)

Event Loop。在程序中设置两个线程：一个负责程序本身的运行，称为“主线程”；另一个负责主线程与其他进程（主要是各种IO操作）的通信，被称为Event Loop线程（消息线程）

每当遇到IO时，主程序就让Event Loop线程去通知相应的IO程序，然后接着往后运行，所以不存在等待时间。等到IO程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。（异步模式，非阻塞模式）

异步执行的运行机制
- 所有同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件
- 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
- 主线程不断重复上面第三步

#### 事件和回调函数
- "任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

- "任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

- 所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

- "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在任务队列中加入各种事件（click，load，done）。只要执行栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。

```
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.send();
    req.onload = function (){};    
    req.onerror = function (){};   
```
指定回调函数的部分（onload和onerror）(callback queue)，在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取"任务队列"。
#### 定时器
任务队列：放置异步任务、定时事件，即指定某些代码在多少事件之后执行。“timer”功能。

setTimeout()：两个参数，一个是回调函数、一个是推迟执行的毫秒数
```
setTimeout(function(){console.log(1);}, 0);
console.log(2);
```
上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数。

h5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。

setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。

## 三次握手
[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。







